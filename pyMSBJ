python语言特性
	python是静态动态类型？是强类型还是弱类型？
		动态类型语言(不少人误以为是弱类型)
		动态还是静态指的是编译期还是运行期确定类型
		强类型指的是不会发生隐式类型转换

	python作为后端语言优缺点
		为什么要用python?
			胶水语言,轮子多，应用广泛
			语言灵活，生产力搞
			性能问题，代码维护问题、python2/3兼容问题
	 什么是monkey patch?哪些地方用到了？自己如何实现
	 所谓的monkey patch 就是运行时替换
	 
	 什么是自省？
	 Introspection
	 	运行时判断一个对象的类型的能力
	 	python一切皆对象，用type,id,isinstance获取对象类型信息
	 	Inspect模块提供了很多获取对象信息的函数
	 
	 列表字典生成器推导式

	 python2/3差异常考题
	 python3
	 print成为了函数
	 编码问题，python3不再有Unicode对象，默认str就是unicode
	 除法变化，python3除号返回浮点数
	 
	 python3改进
	 类型注解 （type hint）。帮助IDE实现类型检查
	 优化的super()方便直接调用父类函数
	 py2=> return super(C,self).hello()
	 py3=> return super().hello()
	 
	 高级的解包操作，a,b,*rest = range(10)
	 py2=> a,b,c=[1,2,3]
	 py3=> a,b,*c=range(10) a,b,*_=range(5)
	 
	 限定关键字参数
	 def add(a,b,*,c) *后面传参得指定参数名
	 
	 python重新抛出异常不会丢失栈信息
	 
	 一切返回迭代器
	 py2=> range(10)--[1,2,3,4,5..]
	 py3=> range(10)--range(0,10)
	 
	 生成的pyc文件统一放到__pycache__
	 一些内置库的修改。urllib,selector灯
	 性能优化等。。。
	 
	 
	 python3新增
	 yidld from 链接子生成器
	 asyncio内置库, async/await原生协程支持异步编程
	 新的内置库enum,mock,asyncio,ipaddress,concurrent.futures等
	 
	 python2/3工具
	 熟悉一些兼容2/3的工具
	 
	 six模块
	 2to3 等工具转换代码
	 __future__
	 
	 python如何传递参数
	唯一支持的参数传递是共享传参，函数形参获取实参中各个引用的副本
	
	python可变/不可变对象
	哪些是可变对象？哪些是不可变的
	不可变对象 bool/int/float/tuple/str/frozenset
	可变对象 list/set/dict
	
	python可变参数作为默认参数---默认参数只计算一次
	
	python *args,**kwargs含义是什么
		用来处理可变参数
		*args被打包成tuple
		**kwargs被打包成dict
	
	python异常
		什么时候需要捕获处理异常呢？看python内置异常的类型
			网络请求（超时，连接错误等）
			资源访问（权限问题，资源不存在）
			代码逻辑（越界访问，keyError等）
	
	什么是Cpython GIL
		Cpython解释器的内存管理并不是线程安全的
		保护多线程情况下对python对象的访问
		Cpython使用简单的锁机制避免多个线程同时执行字节码
	
	GIL的影响
		限制了程序的多核执行
			同一个时间只能有一个线程执行字节码
			CPU密集程序难以利用多核优势（偏计算）
			IO期间会释放GIL，对IO密集程序影响不大（偏网络传输）
			
	如何规避GIL影响
		区分CPU和IO密集程序
			CPU密集可以使用多进程+进程池
			IO密集使用多线程/协程
			cython扩展
	为什么有了GIL还要关注线程安全（3-5图归档--线程安全）
		python中什么操作才是原子的？一步到位执行完
			一个操作如果是一个字节码指令可以完成就是原子的
			原子的是可以保证线程安全的
			使用dis操作来分析字节码
		
	如何剖析程序性能
		使用各种profile工具（内置或第三方）
			二八定律，大部分时间耗时在少量代码上
			内置的profile/cprofile等工具
			使用pyflame(uber开源)的火焰图工具
	
	服务端性能优化措施
		web应用一般语言不会成为瓶颈
			数据结构与算法优化
			数据库层：索引优化，慢查询消除，批量操作减少IO, NoSQL
			网络IO：批量操作，pipeline操作减少IO
			缓存：使用内存数据库 redis/memcached
			异步：asyncio,celery
			并发：gevent/多线程
	
	python生成器与协程
	
	什么是生成器（3-6代码截图）
		生成器就是可以生成值的函数
		当一个函数里有了yield关键字就成了生成器
			生成器可以挂起执行并且保持当前执行的状态
	
	基于生成器的协程（3-6 代码截图）
		python3之前没有原生协程，只有基于生成器的协程
			pep 342增强生成器功能
			生成器可以通过yield暂停执行和产出数据
			同时支持send()向生成器发送数据和throw()向生成器抛异常
	
	协程的注意点
		协程需要使用send(None)或者next(coroutine)来【预激】(prime)才能启动
		在yield处协程会暂停执行
		单独的yield value会产出值给调用方
		可以通过coroutine.send(value)来给协程发送值，发送的值会赋值给yield表达式左边的变量value=yield
		协程执行完成后（没有遇到下一个yield语句）会抛出Stoplteraiton异常
	
	协程装饰器（3-6代码截图）
	
	python3原生协程（3-6代码截图）
	
	python单元测试
		什么是单元测试
			针对程序模块进行正确性检验
			一个函数,一个类进行验证
			自底向上保证程序正确性
		为什么要写单元测试
			保证代码逻辑的正确性（甚至有些采用测试驱动开发（TDD））
			单测影响设计，易测的代码往往是高内聚低耦合的
			回归测试,防止改一处整个服务不可用
		
		单元测试相关的库
			nose/pytest较为常用
			mock模块用来模拟替换网络请求等
			coverage统计测试覆盖率
		
	python基础练习题
		深拷贝和浅拷贝的区别
			什么是深拷贝？什么是浅拷贝？
			python中如何实现深拷贝？
			思考：python中如何正确初始化一个二维数组？

0329--94

常用的内置数据结构和算法（4-1截图）
collections模块（4-1截图）

python dict 底层结构
	dict底层使用的哈希表
		为了支持快速查找使用了哈希表作为底层结构
		哈希表平均查找时间复杂度O(1)
		CPython解释器使用二次探查解决哈希冲突问题
	哈希表是如何解决哈希冲突的？
		链接法和探查法（线性探查，二次探查）
	哈希表是如何扩容的？

python list/tuple区别
	都是线性结构，支持下标访问
	list是可变对象，tuple保存的引用不可变
	list没法作为字典的key,tuple可以（可变对象不可hash）
 
什么是LRUCache?
	Least-Recently-Used替换掉最近最少使用的对象
		缓存剔除策略，当缓存控件不够用的时候需要一种方式剔除key
		常见的有LRU，LFU等
		LRU通过使用一个循环双端队列不断把最新访问的key放到表头实现 
	
	如何实现LRUCache?
		字典用来缓存，循环双端链表用来记录访问顺序
			利用python内置的dict+collections.OrderedDict实现
			dict用来当做k/v键值对的缓存
			OrderedDict用来实现更新最近访问的key

算法常考题
	排序+查找，重中之重
		常考排序算法：冒泡排序，快速排序，归并排序，堆排序
		线性查找，二分查找等
		能独立实现代码（手写），能够分析时间空间复杂度
	常用排序算法的时空复杂度（4-2截图）
	
	python web 后端常考数据结构
		常见的数据结构链表，队列，栈，二叉树、堆
		使用内置结构实现高级数据结构，比如内置的list/deque实现栈
		Leetcode或者《剑指offer》上的常见题
	
	常考数据结构之链表
		链表有单链表、双链表、循环双端链表
			如何使用python来标识链表结构
			实现链表常见操作，比如插入节点，反转链表，合并多个链表等
			Leetcode联系常见链表题目
	
	数据结构之链表（4-3 截图）
	数据结构之队列 (0330)
		队列是先进先出结构
			如何使用python实现队列
			实现队列的apend和pop操作，如何做到先进先出
			使用python的list或者collections.deque实现队列
		collections.deque图解 （4-3 9:33）
		思考题:能不能用list来实现
	
	数据结构之栈
		栈是后进先出结构（放盘子）
			如何使用python实现栈
			实现栈的push和pop操作，如何做到后进先出
			同样可以用python list或者collections.deque实现栈
	
	常考数据结构之字典与集合
		python dict/set 底层都是哈希表
			哈希表的实现原理，底层其实就是一个数组
			根据哈希函数快速定位一个元素，平均查找O(1)，非常快
			不断加入元素会引起哈希表重新开辟空间，拷贝之前元素到新数组
		哈希表如何解决冲突
			链接法和开放寻址法
				元素key冲突之后使用一个链表填充相同key的元素
				开放寻址法是冲突之后根据一种方式（二次探查）寻找下一个可用的槽
				cpython使用的二次探查
	常考数据结构之二叉树
		 先(根)序：先处理根，之后是左子树，然后是右子树
		 中(根)序：先处理左子树，然后是跟，然后是右子树
		 后(根)序: 先处理左子树，然后是右子树，最后是根
		 
		 图解4-3（19:46）
		 先序遍历代码截图4-3（21:03）
		 中序遍历代码截图4-3（21:46）
		 
	常考数据结构之堆
		堆其实就是完全的二叉树，有最大堆和最小堆
			最大堆：对于每个非叶子节点V，V的值都比它的两个孩子大
			最大堆支持每次pop操作获取最大的元素，最小堆获取最小的元素
			常见问题：用堆来完成topk问题，从海量数字中寻找最大的k个
		图解4-3（24:03）
		代码截图4-3
	
	python白板编程（手写代码）
		什么是白板编程
			传说中的手写算法题，白纸或者白板上手写代码
				对于没有参与ACM/蓝桥杯之类算法竞赛的同学比较吃亏
				刷题。LeetCode 《剑指offer》 看github题解
				最近某大型互联网多年经验跳槽出来因为算法题面挂小公司
		为啥要手写算法题
			工作用不到，为啥还要考？
				有些公司为了筛选编程能力强的同学，近年来对算法要求越来越高
				针对刚出校门的同学问得多，有经验的反而算法考得少（偏工程经验）
				竞争越来越激烈，大家水平差不多的优先选取有算法竞赛经验的
			如何准备？
				没有太多好的方式，刷常见题。防止业务代码写多了算法手生
					刷题，LeetCode常见题，不要靠记忆而是真正的理解掌握
					打好基础是重点，面试可以刷常见题突击，保持手感
			面试前练习
				刷题（leetcode+剑指offer+看面经）
					《剑指offer》上常见题用python实现
						把Leetcode上常见分类题目刷一遍（github搜leetcode分类）
						常见排序算法和数据结构能手写
	
	链表
		链表涉及到指针操作较为复杂，容易出错，经常用作考题
			熟悉链表的定义和常见操作
			常考题：删除一个链表节点
			常考题：合并两个有序链表
