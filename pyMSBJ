python语言特性
	python是静态动态类型？是强类型还是弱类型？
		动态类型语言(不少人误以为是弱类型)
		动态还是静态指的是编译期还是运行期确定类型
		强类型指的是不会发生隐式类型转换

	python作为后端语言优缺点
		为什么要用python?
			胶水语言,轮子多，应用广泛
			语言灵活，生产力搞
			性能问题，代码维护问题、python2/3兼容问题
	 什么是monkey patch?哪些地方用到了？自己如何实现
	 所谓的monkey patch 就是运行时替换
	 
	 什么是自省？
	 Introspection
	 	运行时判断一个对象的类型的能力
	 	python一切皆对象，用type,id,isinstance获取对象类型信息
	 	Inspect模块提供了很多获取对象信息的函数
	 
	 列表字典生成器推导式

	 python2/3差异常考题
	 python3
	 print成为了函数
	 编码问题，python3不再有Unicode对象，默认str就是unicode
	 除法变化，python3除号返回浮点数
	 
	 python3改进
	 类型注解 （type hint）。帮助IDE实现类型检查
	 优化的super()方便直接调用父类函数
	 py2=> return super(C,self).hello()
	 py3=> return super().hello()
	 
	 高级的解包操作，a,b,*rest = range(10)
	 py2=> a,b,c=[1,2,3]
	 py3=> a,b,*c=range(10) a,b,*_=range(5)
	 
	 限定关键字参数
	 def add(a,b,*,c) *后面传参得指定参数名
	 
	 python重新抛出异常不会丢失栈信息
	 
	 一切返回迭代器
	 py2=> range(10)--[1,2,3,4,5..]
	 py3=> range(10)--range(0,10)
	 
	 生成的pyc文件统一放到__pycache__
	 一些内置库的修改。urllib,selector灯
	 性能优化等。。。
	 
	 
	 python3新增
	 yidld from 链接子生成器
	 asyncio内置库, async/await原生协程支持异步编程
	 新的内置库enum,mock,asyncio,ipaddress,concurrent.futures等
	 
	 python2/3工具
	 熟悉一些兼容2/3的工具
	 
	 six模块
	 2to3 等工具转换代码
	 __future__
	 
	 python如何传递参数
	唯一支持的参数传递是共享传参，函数形参获取实参中各个引用的副本
	
	python可变/不可变对象
	哪些是可变对象？哪些是不可变的
	不可变对象 bool/int/float/tuple/str/frozenset
	可变对象 list/set/dict
	
	python可变参数作为默认参数---默认参数只计算一次
	
	python *args,**kwargs含义是什么
		用来处理可变参数
		*args被打包成tuple
		**kwargs被打包成dict
	
	python异常
		什么时候需要捕获处理异常呢？看python内置异常的类型
			网络请求（超时，连接错误等）
			资源访问（权限问题，资源不存在）
			代码逻辑（越界访问，keyError等）
	
	什么是Cpython GIL
		Cpython解释器的内存管理并不是线程安全的
		保护多线程情况下对python对象的访问
		Cpython使用简单的锁机制避免多个线程同时执行字节码
	
	GIL的影响
		限制了程序的多核执行
			同一个时间只能有一个线程执行字节码
			CPU密集程序难以利用多核优势（偏计算）
			IO期间会释放GIL，对IO密集程序影响不大（偏网络传输）
			
	如何规避GIL影响
		区分CPU和IO密集程序
			CPU密集可以使用多进程+进程池
			IO密集使用多线程/协程
			cython扩展
	为什么有了GIL还要关注线程安全（3-5图归档--线程安全）
		python中什么操作才是原子的？一步到位执行完
			一个操作如果是一个字节码指令可以完成就是原子的
			原子的是可以保证线程安全的
			使用dis操作来分析字节码
		
	如何剖析程序性能
		使用各种profile工具（内置或第三方）
			二八定律，大部分时间耗时在少量代码上
			内置的profile/cprofile等工具
			使用pyflame(uber开源)的火焰图工具
	
	服务端性能优化措施
		web应用一般语言不会成为瓶颈
			数据结构与算法优化
			数据库层：索引优化，慢查询消除，批量操作减少IO, NoSQL
			网络IO：批量操作，pipeline操作减少IO
			缓存：使用内存数据库 redis/memcached
			异步：asyncio,celery
			并发：gevent/多线程
	
	python生成器与协程
	
	什么是生成器（3-6代码截图）
		生成器就是可以生成值的函数
		当一个函数里有了yield关键字就成了生成器
			生成器可以挂起执行并且保持当前执行的状态
	
	基于生成器的协程（3-6 代码截图）
		python3之前没有原生协程，只有基于生成器的协程
			pep 342增强生成器功能
			生成器可以通过yield暂停执行和产出数据
			同时支持send()向生成器发送数据和throw()向生成器抛异常
	
	协程的注意点
		协程需要使用send(None)或者next(coroutine)来【预激】(prime)才能启动
		在yield处协程会暂停执行
		单独的yield value会产出值给调用方
		可以通过coroutine.send(value)来给协程发送值，发送的值会赋值给yield表达式左边的变量value=yield
		协程执行完成后（没有遇到下一个yield语句）会抛出Stoplteraiton异常
	
	协程装饰器（3-6代码截图）
	
	python3原生协程（3-6代码截图）
	
	python单元测试
		什么是单元测试
			针对程序模块进行正确性检验
			一个函数,一个类进行验证
			自底向上保证程序正确性
		为什么要写单元测试
			保证代码逻辑的正确性（甚至有些采用测试驱动开发（TDD））
			单测影响设计，易测的代码往往是高内聚低耦合的
			回归测试,防止改一处整个服务不可用
		
		单元测试相关的库
			nose/pytest较为常用
			mock模块用来模拟替换网络请求等
			coverage统计测试覆盖率
		
	python基础练习题
		深拷贝和浅拷贝的区别
			什么是深拷贝？什么是浅拷贝？
			python中如何实现深拷贝？
			思考：python中如何正确初始化一个二维数组？
